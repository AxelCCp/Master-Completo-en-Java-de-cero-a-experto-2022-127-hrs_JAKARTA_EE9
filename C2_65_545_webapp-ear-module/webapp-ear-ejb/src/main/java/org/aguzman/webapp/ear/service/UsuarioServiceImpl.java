package org.aguzman.webapp.ear.service;

import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import org.aguzman.webapp.ear.ejb.entity.Usuario;
import org.aguzman.webapp.ear.repository.UsuarioRepository;

import java.util.List;

//547
//1 - SE MARCA COMO UN EJB. PODRÍA SE STATELESS O STATEFUL. SI FUERA STATEFUL, SE PODRÍA ANOTAR CON UN CONTEXTO, POR EJEMPLO Q TAMBN SEA DEL REQUEST, IGUAL Q EL REPOSITORY.
    //STATELESS Y STATEFUL, ESTARIAN BIEN, YA QUE LA CONEXION, O SEA EL ENTITY MANAGER,  ES DEL REQUEST.
    //SI ESTE EJB ES STATELESS, CADA CLIENTE Q OBTENGA UNA INSTANCIA DE ESTE EJB, VA A MANEJAR SU PROPIO CONTEXTO DEL REQUEST, POR LO TANTO EL CLIENTE VA A MANEJAR SU PROPIO ENTITY MANAGER. CON ESTO, NO HA A HABER CONFLICTO CON LOS DEMÁS USUARIOS, YA Q CADA USUARIO VA A TENER SU PROPIA TRANSACCION.
    //AHORA, SI ES STATEFUL, SE DEJA COMO DEL CONTEXTO DEL REQUEST.

//2 - SE ESTA INYECTANDO UN COMPONENTE CDI DEL CONTEXTO DEL REQUEST EN UN STATELESS.

// nota :  AQUI SE ESTA MANEJANDO UN PROXY. POR LO TANTO, CADA CLIENTE QUE OBTIENE ESTE EJB STATELESS, VA A MANEJAR SU PROPIO REQUEST.

// nota : LOS MÉTODOS DEL EJB SON TRANSACCIONALES, POR DEFECTO. POR LO TANTO NO SE NECESITA EL BEGIN() EL COMMIT() EL ROLLBACK() , ETC(). TAMPOCO SE NECESITAN INTERCEPTORES. YA..
        //..QUE TOD0 ESTO LO MANEJA "JTA" DENTRO DEL CONTENEDOR EJB EN EL SERVIDOR DE WILDFLY.

@Stateless  //1
public class UsuarioServiceImpl implements UsuarioService{

    @Inject //2
    private UsuarioRepository repository;

    @Override
    public List<Usuario> listar() {
        return repository.listar();
    }

}
